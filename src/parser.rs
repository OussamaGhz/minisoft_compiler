use crate::ast::Program;
use crate::lexer::{Token, lex};
use lalrpop_util::lalrpop_mod;

// Generate the parser code from the grammar file
lalrpop_mod!(grammar); // this will expand to include the parser code generated by LALRPOP

pub struct TokenIterator {  // Remove the unused lifetime parameter
    tokens: Vec<(usize, Token, usize)>,
    pos: usize,
}

impl TokenIterator {
    pub fn new(input: &str) -> Self {
        let lexed_tokens = lex(input);
        let tokens: Vec<_> = lexed_tokens
            .into_iter()
            .map(|result| {
                let span = result.span;
                (span.start, result.token, span.end)
            })
            .collect();
        
        TokenIterator {
            tokens,
            pos: 0,
        }
    }
}

impl Iterator for TokenIterator {
    type Item = Result<(usize, Token, usize), String>;

    fn next(&mut self) -> Option<Self::Item> {
        if self.pos < self.tokens.len() {
            let (start, token, end) = self.tokens[self.pos].clone();
            self.pos += 1;
            Some(Ok((start, token, end)))
        } else {
            None
        }
    }
}

pub fn parse(input: &str) -> Result<Program, String> {
    let token_iterator = TokenIterator::new(input);
    
    match grammar::ProgramParser::new().parse(token_iterator) {
        Ok(program) => Ok(program),
        Err(err) => Err(format!("Parse error: {:?}", err)),
    }
}